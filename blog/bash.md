# bash基础

## bash简介

bash是linux自带的一种脚本语言，可以分为bash、sh和zsh等多种不同的分支。

在当前python脚本语言功能和生态均已十分完善的情况下，再深入研究bash的使用方法已经没有太大的必要了。但是对于一些简单的逻辑和使用，使用bash能够在替代手动输入和调用系统的工具有着比较高的效率，所以在逻辑不是很复杂的场景中也是一个可选的选项。

本文作为一个bash基本语法的介绍，便于以后自己什么时候需要写简单bash脚本了能够快捷的捡起以前写的一些经验。

## 常用变量

格式|含义|其他
---|---|---
$var | 引用变量 | -
$0 / $n | 脚本的输入变量内容| 默认为字符串
$# | 输入参数个数 | -
$? | 上一命令的运行成功状态 | -
$$ | pid |-
$! | 后台process的pid|-
$@/$* | 参数列表 | -
!#/bin/bash | 调用的bash分支 | 在脚本起始行
sleep n | 休眠函数|-

## 条件语句

### if

bash中if的格式为

```bash
if [ condition ]; then
  #do some work
fi
```

### case

case中的结果支持正则表达式，比如最后的*就是将所有可能包括在内。

```bash
case expression in
  e1) cmd1;;
  e2) cmd2;;
  *) cmdn;;
esac
```

### 条件

常用的条件语句有

|  例子 | 含义 | 同类关键词
|---|---|---
| [ inter == 0 ]| 判断数值是否相等|!=/ -ne <br> '>' / -gt <br> / '<' / -lt <br> '>=' / -ge <br> '<=' / -le|
| [[string =~ regex]] | 正则匹配 | -
| [-d file ] | 判断文件是否存在 | -a/e ：文件存在 <br> -b : 块文件 <br> -c ：字符文件 <br> -d : 目录 <br> -f: 普通文件 <br> -g：有组id <br> -G 有效组id<br> -h/L：符号链接 <br> -k static bit <br> -N: 是否上次被修改 <br> -O:有效的用户id <br> -p: 命名管道 <br> -r/w/x: 访问权限 <br> -s：非空文件 <br> -S：socket文件 <br> -t: 文件描述符并指向终端 <br> -u：user id |
|[f1 -nt f2] | 文件更新时间 | -ot：f1更新时间晚于f2 <br> -ef 拥有相同设备和inode编号|
| [string] | 字符串是否为空 | |
| [-z string] | 字符串长度等于零 | -n：字符串长度等于零|
| [s1 = s2] | 字符串相等 | = / == / '>' / '<' / !=|
|((3 > 6)) | 算数判断 | |

>注：这里'>'要使用引号括起来或者使用\>转义字符

## 逻辑运算

除了使用if等方法，也可以使用test + 上述条件语句方式进行判断。

* cmd1 && cmd2 ：当cmd1运行成功后运行cmd2
* cmd1 || cmd2 ：如果cmd1运行失败运行cmd2

## 循环语句

### for

```bash
for iter in list
do 
  #do some thing
done

for((;;))
do
  #do some thing
done
```

## 列表

在for循环中需要有一系列列表以保证循环能不断进行，当列表结束或者列表为空时候循环结束。

格式|含义|其他
---|---|---
1 2 3 4 5 | 枚举列表中所有内容| -
{1..5} | 根据起始和终止生成列表| 需要bash3.0
{1..5..1}| 根据起始、终止和间隔生成列表|需要bash 3.0
seq 1 1 5| 使用seq命令生成|-
((iter=begin;end_condition;step))|与c类似|-
${var[@]} | 使用字符串数组 | var=('1' '2' '3')
/etc/* | 列举文件名 | -
0{1..5} | 在列举过程中添加固定字符|输出为01/02/03/04/05
$(ls /etc/*.pdf) | 使用命令添加列表| -


## 重定向

格式|含义
---|---
 \>|将输出内容覆盖到文件中
 \>>|将输出内容以追加方式添加到文件中
 1> |将命令正确运行时候的log输出
 2>> |将命令错误运行时候log输出
 \*> |将所有log输出
 \> /dev/null| 将输出丢弃
